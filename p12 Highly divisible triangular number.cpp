/*
author: Lucy Peony
email:lucypeony@hotmail.com
*/
/*
the problem: 
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
Let us list the factors of the first seven triangle numbers:
	?1: 1
	?3: 1,3
	?6: 1,2,3,6
	10: 1,2,5,10
	15: 1,3,5,15
	21: 1,3,7,21
	28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.
What is the value of the first triangle number to have over five hundred divisors?

*/

#include<iostream>
#include<fstream>
#include<vector>
#include<cmath>
#include<algorithm>
#include<string.h>
#include<climits>

using namespace std;

int factors(long long x){
	long res=0;
	for(int i=1;i<=sqrt(x);i++){
		if(x%i==0)
		{
			res++;
			if(i!=(x/i))
				res++;
		}
	}

	return res;
}

/*
this is a very naive method to solve this problem. 
very naive , very brute force . :) 
*/
void solve(){
	const int N=13000;        //upper limit 
	long long tri[N+1];
	for(long long i=2;i<=N;i++){
		tri[i]=(i*(i+1))/2;
		int NUM=factors(tri[i]);
		//fout<<i<<" "<<tri[i]<<" "<<NUM<<endl;
		if(NUM>=500)    	//if number of factors >= 500    
			break;
	}
}

/*
Can we do better? 

Any number N can be expressed as follows: 
N= p1^a1 * p2^a2 * ... ... * pi^ai. 
p is prime. 

if x = p^a. then x has a+1 factors: p^0,p^1,p^2,... ... p^a. 

Every prime in prime expression has a similar contribution. And they are also  independent with each other. 

so let D(N) be numbers of N. 
then D(N)=(a1+1)*(a2+1)*.... ...*(ai+1)  

So we can use a prepared prime array to do prime expression first, then calculate the D(N).                                         
*/
const int MAX_P= 2000; //number of primes generated 
int primes[MAX_P+1];
void generate_primes(){
	//using prime sieve to generate MAX_P primes
	const int MAX_N=100000; 
	bool temp[MAX_N+1];
	memset(temp,1,sizeof(temp));
	int count=1;
	
	while(count<=MAX_P){
		int x=2;
		for(;x<=MAX_N;x++){
		if(temp[x]){
				primes[count++]=x;
				break;		//smallest unused 
			}
			
		}
	
		for(int i=1;i*x<=MAX_N;i++){
			if(temp[x*i])
				temp[x*i]=false;
		}
		x++;
	}
	
	/*
	for(int i=1;i<=MAX_P;i++)
		cout<<primes[i]<<" ";
	*/
}

void better(){
	generate_primes();
	int count=0;int i=2;
	long long M,N;
	while(count<500){
		 N=i*(i+1)/2;
		 M=N;
		count=1;
		//the prime expression of N
		int j=1;
		while(N>1){
			while(N % primes[j]!=0)
				j++;
			int x=0;
			while(N % primes[j]==0){
				N /=primes[j];
				x++;
			}
			count*=x+1;    //calculate the number of factors of N. 
		}
		i++;
	}
	cout<<M;
}


/*
Can We do better? II
N=1+2+3+... ...+n, N=n*(n+1)/2
so, we can just calculate the factor numbers of n and (n+1)/2,(if n+1 is even) . 
D(N)=D(n)*D((n+1)/2) if n+1 is even;
D(N)=D(n/2)*D(n+1) if n is even. 
n is much smaller than N. 
We can use the similar method, to calculate D(n) or D(n+1),etc, then we can get D(N)
the prime array used here can be much smaller than the last one. 
*/
void besser(){
	generate_primes();
	int count=1; int i=2;
	long long N;
	while(count<500){
		count=1;
		int x,y;
		if(i%2==0){
			x=i/2;
			y=i+1;
		}else{
			x=(i+1)/2;
			y=i;
		}
		N=x*y;
		int xcount=1;
		while(x>1){
		//calculate the prime expressions of y 
			int j=1;
			while(x%primes[j]!=0){
				j++;
			}
			int t=1;
			while(x%primes[j]==0){
				x/=primes[j];
				t++;
			}
			xcount*=t;	
		}
	
		int ycount=1;
		while(y>1){
			//calculate the prime expression of y
			int k=1;
			while(y%primes[k]!=0){
				k++;
			}
			int m=1;
			while(y%primes[k]==0){
				y/=primes[k];
				m++;
			}
			ycount*=m;
		}
		
		count=xcount*ycount;
		i++;	
	}
	
	cout<<N;
}


using namespace std;

int main(){
	besser();
	return 0;
}
